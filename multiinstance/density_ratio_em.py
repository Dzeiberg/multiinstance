# AUTOGENERATED! DO NOT EDIT! File to edit: 47_DREM_2.ipynb (unless otherwise specified).

__all__ = ['DensityRatioEM', 'DensityRatioEM', 'generateParams']

# Cell
from .em import generateBags
from .utils import estimate
from .nnpu import getPosterior as getNNPUPosterior
from .vpu import train as getVPUPosterior

import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as ss
from sklearn.cluster import KMeans
from sklearn.metrics import roc_auc_score
from easydict import EasyDict
from scipy.spatial.distance import cdist
from tqdm.notebook import tqdm

# Cell
class DensityRatioEM:
    def __init__(self, bags,n_clusters):
        self.bags = bags
        self.n_clusters = n_clusters
        self.findGlobalClusters()
        self.tau_posS = None
        self.tau_uS = None
        self.clusterAlphaHats = None

    def findGlobalClusters(self):
        "Run K-Means on the positives from all bags then assign each unlabeled point to a cluster based on the resulting clusters of K-Means"
        globalPositives = np.concatenate([b.X_pos for b in bags])
        kmeans = KMeans(n_clusters=self.n_clusters).fit(globalPositives)
        # Cluster Unlabeled
        for bagNum,b in enumerate(self.bags):
            self.bags[bagNum].unlabeled_cluster_assignment = kmeans.predict(b.x_unlabeled)
            self.bags[bagNum].positive_cluster_assignment = kmeans.predict(b.X_pos)
        self.kmeans = kmeans

    def getClusterEstimates(self,componentInfo=None,pupost=None,inputs=None,trainOnRanks=False,useLabels=False,useVPU=True):
        "Estimate the class prior and density ratios of the unlabeled points for each cluster"
        estAlpha=False
        if self.clusterAlphaHats is None:
            estAlpha = True
            self.clusterAlphaHats= np.zeros(self.n_clusters)
        # NClusters x NBags size list containing the density ratio for the unlabeled points
        # from the specified bag in the specified cluster
        self.bagRatios = []
        for cnum in tqdm(range(self.n_clusters),total=self.n_clusters,leave=False):
            labels = None
            if useLabels:
                labels = [b.hiddenLabels[b.unlabeled_cluster_assignment == cnum] for b in self.bags]
            unlabeledInCluster = [b.x_unlabeled[b.unlabeled_cluster_assignment == cnum] for b in self.bags]
            posInCluster = [b.X_pos[b.positive_cluster_assignment == cnum] for b in self.bags]
            unlabeled = np.concatenate(unlabeledInCluster)
            positive = np.concatenate(posInCluster)
            # estimate class prior
            if estAlpha:
                tau, aucpu = getOptimalTransform(np.concatenate((positive, unlabeled)),
                                             np.concatenate((np.ones(positive.shape[0]),
                                                             np.zeros(unlabeled.shape[0]))))
                tau_pos = np.ascontiguousarray(tau[:positive.shape[0]].reshape((-1,1)))
                tau_u = np.ascontiguousarray(tau[positive.shape[0]:].reshape((-1,1)))
                #self.tau_posS.append(tau_pos)
                #self.tau_uS.append(tau_u)
                self.clusterAlphaHats[cnum],_ = estimate(tau_pos, tau_u)


            ####
            # Estimate density ratio for all unlabeled points in each bag that are in this cluster
            self.bagRatios.append(self.estimateClusterDensityRatio(posInCluster,
                                                                   unlabeledInCluster,
                                                                   cnum,
                                                                   componentInfo=componentInfo,
                                                                   pupost=pupost,
                                                                   inputs=inputs,
                                                                   labels=labels,
                                                                   useVPU=useVPU,
                                                                  trainOnRanks=trainOnRanks))

    def ratioFromPosteriorVec(self, posts, alpha):
        return (alpha * (1 - posts)) / (posts * (1 - alpha))

    def estimateClusterDensityRatio(self,posInCluster,unlabeledInCluster,cnum,
                                    componentInfo=None,
                                    pupost=None,
                                    inputs=None,
                                    trainOnRanks=False,
                                    labels=None,
                                    useVPU=True,
                                    args=EasyDict(d={'batchsize': 128,
                                                     'hdim': 300,
                                                     'epochs': 250,
                                                     'lr': 0.001,
                                                     'weightDecayRate': 0.005})):
        p = np.concatenate(posInCluster)
        u = np.concatenate(unlabeledInCluster)
        xPU = np.concatenate((p,u))
        # PU Labels {1: pos, -1: unlabeled}
        y = np.concatenate((np.ones((p.shape[0],1)),
                            np.zeros((u.shape[0],1)))).astype(np.int32)
        # Run NNPU
        if labels is not None:
            posteriors,auc = getOptimalTransform(xPU,np.concatenate((np.ones(p.shape[0]),
                                                                     *labels)))
            ratios = np.nan_to_num(self.ratioFromPosteriorVec(posteriors, self.clusterAlphaHats[cnum]))
        elif componentInfo is not None:
            clusterMap = cdist(self.kmeans.cluster_centers_, componentInfo.posMeans).argmin(1)
            # pos
            if trainOnRanks:
                ranks = ss.rankdata(componentInfo.dgs[clusterMap[cnum]].pu_posterior(xPU))[:,None]
                ranks = (ranks - ranks.min()) / (ranks.max() - ranks.min())

                posteriors,net = getNNPUPosterior(xPU.astype(np.float32),
                                                  y,
                                                  self.clusterAlphaHats[cnum],
                                                  inputs=ranks.astype(np.float32),
                                                  distributions=EasyDict({"true_posterior" : componentInfo.dgs[clusterMap[cnum]].pn_posterior_cc,
                                                                          "f1" : componentInfo.dgs[clusterMap[cnum]].dens_pos,
                                                                          "f0" : componentInfo.dgs[clusterMap[cnum]].dens_neg}),)
                ratios = np.nan_to_num(self.ratioFromPosteriorVec(posteriors, self.clusterAlphaHats[cnum]))
            else:
                f1 = ss.multivariate_normal.pdf(xPU,
                                     mean=componentInfo.posMeans[clusterMap[cnum]],
                                     cov=componentInfo.posCovs[clusterMap[cnum]])
                # Neg
                f0 = ss.multivariate_normal.pdf(xPU,
                                     mean=componentInfo.negMeans[clusterMap[cnum]],
                                     cov=componentInfo.negCovs[clusterMap[cnum]])
                ratios = f0/f1
        else:
            if useVPU:
                posteriors = getVPUPosterior(xPU,y.astype(bool))
            else:
                posteriors,net = getNNPUPosterior(xPU.astype(np.float32),
                                                  y,
                                                  self.clusterAlphaHats[cnum],
                                                  pupost=pupost,inputs=inputs)
            # convert cluster posterior to density ratio
            ratios = np.nan_to_num(self.ratioFromPosteriorVec(posteriors, self.clusterAlphaHats[cnum]))
        # Remove positive points from posterior list
        ratios = ratios[p.shape[0]:]
        # Store the ratios for the unlabeled set of each bag
        bagRatios = []
        # Get ratios for unlabeled sets of each bag
        idx = 0
        for bagNum in range(len(posInCluster)):
            numU = unlabeledInCluster[bagNum].shape[0]
            bagRatios.append(ratios[idx:idx+numU])
            idx += numU
        return bagRatios

    def EM(self,NIters=500):
        self.eta = np.zeros((len(self.bags), self.n_clusters))
        for cnum in range(self.n_clusters):
            for bagNum, b in enumerate(self.bags):
                ratios = self.bagRatios[cnum][bagNum]
                eta_i_j = np.array(.5)
                for em_iter in range(NIters):
                    den = eta_i_j + (1 - eta_i_j) * ratios
                    eta_i_j = np.mean(eta_i_j / den)
                self.eta[bagNum,cnum] = eta_i_j

    def run(self,componentInfo=None,pupost=None,inputs=None,trainOnRanks=False,useLabels=False,useVPU=True):

        self.getClusterEstimates(componentInfo=componentInfo,
                                 pupost=pupost,
                                 inputs=inputs,
                                 trainOnRanks=trainOnRanks,
                                 useLabels=useLabels,
                                 useVPU=useVPU)
        self.EM()
        self.estimateBagParameters()


    def posterior(self, bagNum, clusterNum):
        eta_i_j = self.eta[bagNum, clusterNum]
        densityRatios = self.bagRatios[clusterNum][bagNum]
        return eta_i_j / (eta_i_j + (1 - eta_i_j)*densityRatios)

    def getAUC(self):
        labels = []
        posts = []
        for bagNum in range(len(self.bags)):
            for cnum in range(self.n_clusters):
                posts.append(self.posterior(bagNum,cnum))
                labels.append(self.bags[bagNum].hiddenLabels[self.bags[bagNum].unlabeled_cluster_assignment == cnum])
        labels = np.concatenate(labels)
        posts = np.concatenate(posts)
        return roc_auc_score(labels, posts)

    def estimateBagParameters(self):
        N = len(self.bags)
        self.alphaHats = np.zeros(N)
        self.pi = np.zeros((N,self.n_clusters))
        self.rho = np.zeros((N,self.n_clusters))
        for bagNum, b in enumerate(self.bags):
            eta_j = self.eta[bagNum]
            gamma_j = np.unique(b.unlabeled_cluster_assignment,
                                return_counts=True)[1] / b.unlabeled_cluster_assignment.shape[0]
            alpha_j = eta_j.dot(gamma_j)
            pi_j = np.multiply(eta_j, gamma_j) / alpha_j
            rho_j = np.multiply(1 - eta_j, gamma_j) / (1 - alpha_j)
            self.alphaHats[bagNum] = alpha_j
            self.pi[bagNum] = pi_j
            self.rho[bagNum] = rho_j

# Cell
from .em import generateBags
from .utils import estimate
from .nnpu import getPosterior as getNNPUPosterior
from .vpu import train as getVPUPosterior
from .ranker import RankNet

import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as ss
from sklearn.cluster import KMeans
from sklearn.metrics import roc_auc_score
from easydict import EasyDict
from scipy.spatial.distance import cdist
from tqdm.notebook import tqdm

from .data.gaussian_dg import GaussianMixtureDataGenerator

from dist_curve.transforms import getOptimalTransform, trainOOBClassifier

from .ranker import RankNet, LambdaRankNN

from tqdm.notebook import trange

from sklearn.model_selection import StratifiedKFold
import tensorflow as tf

# Cell
class DensityRatioEM:
    def __init__(self, bags,n_clusters):
        self.bags = bags
        self.n_clusters = n_clusters
        self.findGlobalClusters()
        self.tau_posS = []
        self.tau_uS = []
        self.clusterAlphaHats = np.zeros(n_clusters)
        for cnum in trange(n_clusters,desc="transforms and class prior estimation"):
            self.estimateClusterClassPrior(cnum)

        self.getEta()

    def findGlobalClusters(self):
        "Run K-Means on the positives from all bags then assign each unlabeled point to a cluster based on the resulting clusters of K-Means"
        globalPositives = np.concatenate([b.X_pos for b in self.bags])
        kmeans = KMeans(n_clusters=self.n_clusters).fit(globalPositives)
        # Cluster Unlabeled
        for bagNum,b in enumerate(self.bags):
            self.bags[bagNum].unlabeled_cluster_assignment = kmeans.predict(b.x_unlabeled)
            self.bags[bagNum].positive_cluster_assignment = kmeans.predict(b.X_pos)
        self.kmeans = kmeans

    def getEta(self):
        self.trueEta = np.stack(list(b.eta for b in self.bags))
        self.gamma = np.stack(list(b.gamma for b in self.bags))
        """
        bagClusterCounts = np.zeros_like(self.trueEta)
        for bnum,b in enumerate(self.bags):
            bagCounts = np.unique(b.unlabeled_cluster_assignment,return_counts=True)[1]
            bagClusterCounts[bnum] = bagCounts
        bagClusterCounts = bagClusterCounts / bagClusterCounts.sum(0)
        self.trueclusterAlphaHats = np.zeros(self.n_clusters)
        for cnum in range(self.n_clusters):
            self.trueclusterAlphaHats[cnum] = bagClusterCounts[:,cnum].dot(self.trueEta[:,cnum])
        """

    def getClusterMembers(self,cnum):
        "Get the unlabeled and positive points across all bags that were assigned the given cluster"
        unlabeledInCluster = [b.x_unlabeled[b.unlabeled_cluster_assignment == cnum] for b in self.bags]
        posInCluster = [b.X_pos[b.positive_cluster_assignment == cnum] for b in self.bags]
        unlabeled = np.concatenate(unlabeledInCluster)
        positive = np.concatenate(posInCluster)
        return unlabeled, positive

    def trainTransform(self,cnum):
        "Train and store the univariate PU transform for a given cluster"
        unlabeled,positive = self.getClusterMembers(cnum)
        x = np.concatenate((positive,unlabeled))
        y = np.concatenate((np.ones(positive.shape[0]),
                            np.zeros(unlabeled.shape[0])))
        tau,aucpu = trainOOBClassifier(x,y)
        tau_pos = np.ascontiguousarray(tau[:positive.shape[0]].reshape((-1,1)))
        tau_u = np.ascontiguousarray(tau[positive.shape[0]:].reshape((-1,1)))
        self.tau_posS.append(tau_pos)
        self.tau_uS.append(tau_u)

    def estimateClusterClassPrior(self,cnum):
        "Estimate the class prior for the given cluster"
        self.trainTransform(cnum)
        p,u = self.tau_posS[cnum], self.tau_uS[cnum]
        self.clusterAlphaHats[cnum],_ = estimate(p,u)

    def ratioFromPosteriorVec(self, posts, alpha):
        "convert posterior vector and class prior estimate for a cluster into a density ratio vector"
        assert alpha != 1
        assert ~np.any(posts == 0)
#         assert ~np.any(posts == 1)
        return (alpha * (1 - posts)) / (posts * (1 - alpha))

    def trueDensityRatio(self,cnum):
        """
        Get the true density ratio

        Arguments:
        - cnum : int : cluster number
        """
        # see formatComponentInfo
        comp = self.components[cnum]
        unlabeled,_ = self.getClusterMembers(cnum)
        # Positive density
        f1 = ss.multivariate_normal.pdf(unlabeled,mean=comp.posMean,cov=comp.posCov)
        # Negative density
        f0 = ss.multivariate_normal.pdf(unlabeled,mean=comp.negMean,cov=comp.negCov)
        ratios = f0/f1
        alpha = self.clusterAlphaHats[cnum]
        posts = f1 * alpha / (f1 * alpha + (1-alpha) * f0)
        #ratios = self.ratioFromPosteriorVec(posts,alpha)
        self.debugPosteriors.append(posts)
        hiddenLabels = np.concatenate([b.hiddenLabels[b.unlabeled_cluster_assignment == cnum] for b in self.bags])
        self.debugLabels.append(hiddenLabels)
        print(roc_auc_score(hiddenLabels, posts))
        return ratios

    def trainPNPosterior(self,xPN,yPN):
        "get estimated pn posterior probabilities for given data"
#         posteriors,auc =trainOOBClassifier(xPN,yPN)
#         return posteriors
        skf = StratifiedKFold()
        posteriors = np.zeros_like(yPN,dtype=float)
        for trainInds, valInds in skf.split(xPN,yPN):
            xTrain,xVal,yTrain,yVal = xPN[trainInds],xPN[valInds],yPN[trainInds],yPN[valInds]
            model = tf.keras.Sequential([
                tf.keras.layers.Dense(32,input_shape=(xPN.shape[1],),activation="relu"),
                tf.keras.layers.Dense(32,activation="relu"),
                tf.keras.layers.Dense(32, activation = "relu"),
                tf.keras.layers.Dense(2,activation="softmax")
            ])
            model.compile("adam",loss=tf.keras.losses.BinaryCrossentropy(label_smoothing=0.1))
            model.fit(xTrain,tf.one_hot(yTrain,2),epochs=10,verbose=0)
            posteriors[valInds] = model.predict(xVal)[:,1]
        return posteriors

    def ratioEstimation(self,cnum):
        unlabeled,positive = self.getClusterMembers(cnum)
        hiddenLabels = np.concatenate([b.hiddenLabels[b.unlabeled_cluster_assignment == cnum] for b in self.bags]).ravel().astype(bool)
        logRatio = tf.keras.models.Sequential([
            tf.keras.layers.Dense(128,input_dim=unlabeled.shape[1],activation="relu"),
            tf.keras.layers.Dense(256,activation="relu"),
            tf.keras.layers.Dense(512,activation="relu"),
            tf.keras.layers.Dense(1)
        ])
        xp = unlabeled[hiddenLabels]
        xn = unlabeled[~hiddenLabels]
        NN,NP = xn.shape[0],xp.shape[0]
        xp = xp[np.random.choice(np.arange(xp.shape[0]),size=max(NN,NP),replace=True)]
        xn = xn[np.random.choice(np.arange(xn.shape[0]),size=max(NN,NP),replace=True)]
        x_p = tf.keras.layers.Input(tensor=tf.convert_to_tensor(xp),name="xp")
        x_n = tf.keras.layers.Input(tensor=tf.convert_to_tensor(xn),name="xn")
        log_ratio_p = logRatio(x_p)
        log_ratio_n = logRatio(x_n)
        def _binary_crossentropy(log_ratio_p, log_ratio_q):

            loss_p = tf.nn.sigmoid_cross_entropy_with_logits(
                logits=log_ratio_p,
                labels=tf.ones_like(log_ratio_p)
            )

            loss_q = tf.nn.sigmoid_cross_entropy_with_logits(
                logits=log_ratio_q,
                labels=tf.zeros_like(log_ratio_q)
            )

            return tf.reduce_mean(loss_p + loss_q)

        class PredictionHistory(tf.keras.callbacks.Callback):
            def __init__(self):

                self.predictions = []

            def on_epoch_begin(self, epoch, logs):

                self.predictions.append(logRatio(unlabeled).numpy())
        m = tf.keras.models.Model(inputs=[x_p, x_n], outputs=[log_ratio_p, log_ratio_n])
        m.add_loss(_binary_crossentropy(log_ratio_p, log_ratio_n))
        m.compile(optimizer='rmsprop', loss=None)
        hist_pred = PredictionHistory()
        m.fit(x={"xp":xp,
                 "xn":xn},y=None,steps_per_epoch=1, epochs=500,callbacks=[hist_pred],verbose=0)
        return hist_pred.predictions[-1] * NN/NP

    def densityRatioFromEstimatedPNPosterior(self,cnum):
        "For a given cluster use the true PN labels to train a classifier modeling the PN posterior then calculate density ratio"
        unlabeled,positive = self.getClusterMembers(cnum)
        hiddenLabels = np.concatenate([b.hiddenLabels[b.unlabeled_cluster_assignment == cnum] for b in self.bags])
        posteriors = self.trainPNPosterior(unlabeled,hiddenLabels.astype(bool))
        self.debugLabels.append(hiddenLabels)
        self.debugPosteriors.append(posteriors)
        print("posterior auc ",roc_auc_score(hiddenLabels,posteriors))
        ratios = self.ratioFromPosteriorVec(posteriors,self.clusterAlphaHats[cnum])
        return ratios
        """
        xPN = np.concatenate((positive,unlabeled))
        yPN = np.concatenate((np.ones(positive.shape[0]),hiddenLabels)).astype(bool)
        posteriors = self.trainPNPosterior(xPN,yPN)[positive.shape[0]:]
        print("posteriors auc",roc_auc_score(hiddenLabels, posteriors))
        NP,NU = positive.shape[0], unlabeled.shape[0]
        classPrior = (NP + self.clusterAlphaHats[cnum] * NU) / (NP + NU)
        ratios = self.ratioFromPosteriorVec(posteriors, classPrior)
        return ratios
        """


    def getNNPUInput(self,cnum,inputType):
        """
        Get the input to AbsNNPU

        Arguments:
        - cnum : int : cluster number
        - inputType : {raw,transform,estimated rank,true rank} : space in which AbsNNPU will be trained

        Return Values:
        - xPU : ndarray (n,d) : instances in feature space
        - yPU : ndarray (n,) : PU labels
        - inputs : ndarray (n,k) : instances in space AbsNNPU will be trained
        """
        assert inputType in "raw,transform,estimated rank,true rank".split(",")
        unlabeled,positive = self.getClusterMembers(cnum)
        num_pos = positive.shape[0]
        xPU = np.concatenate((positive,unlabeled))
        yPU = np.concatenate((np.ones(positive.shape[0]), np.zeros(unlabeled.shape[0])))[:,None]
        if inputType == "raw":
            return xPU,yPU,xPU,num_pos
        elif inputType == "transform":
            tauPos, tauU = self.tau_posS[cnum], self.tau_uS[cnum]
            transforms = np.concatenate((tauPos, tauU))
            return xPU,yPU,transforms,num_pos
        elif inputType == "estimated rank":
            # Run RankNet or xgboost
            ranknet = RankNet()
            ranks = ranknet.train(xPU,yPU.ravel().astype(bool))[:,None]
            print("estimated ranks aucpu",roc_auc_score(yPU,ranks))
            return xPU,yPU,ranks,num_pos
        else:
            # True Rank
            puposteriorFn = self.components[cnum].dg.pu_posterior
            ranks = ss.rankdata(puposteriorFn(xPU - self.components[cnum].r))[:,None]
            ranks = (ranks - ranks.min()) / (ranks.max() - ranks.min())
            return xPU,yPU,ranks,num_pos

    def estimatePosteriors(self,x,y,inputs,cnum):
        "Return the estimated pn posteriors"
        posteriors,net = getNNPUPosterior(x.astype(np.float32),
                                          y,
                                          self.clusterAlphaHats[cnum],
                                          inputs.astype(np.float32),
                                          training_args=EasyDict({'n_units': 1000,
                                                         'n_hidden': 10,
                                                         'dropout_rate': 0.5,
                                                         'maxIter': 500,
                                                         'batch_size': 128}))
        return posteriors

    def estimateClusterDensityRatio(self,cnum,inputType):
        x,y,inputs,num_pos = self.getNNPUInput(cnum,inputType)
        posteriors = self.estimatePosteriors(x,y,inputs,cnum)
        posteriors = posteriors[num_pos:]
        hiddenLabels = np.concatenate([b.hiddenLabels[b.unlabeled_cluster_assignment == cnum] for b in self.bags])
        self.debugPosteriors.append(posteriors)
        self.debugLabels.append(hiddenLabels)
        print(roc_auc_score(hiddenLabels, posteriors))
        ratios = self.ratioFromPosteriorVec(posteriors,self.clusterAlphaHats[cnum])
        return ratios

    def splitRatiosIntoBags(self,ratios,cnum):
        "given list of density ratios for all unlabeled points, separate back into lists for each bag"
        bagRatios = []
        numUnlabeled = [b.x_unlabeled[b.unlabeled_cluster_assignment == cnum].shape[0] for b in self.bags]
        endPoints = np.concatenate(([0],np.cumsum(numUnlabeled)))
        for bagNum in range(1, len(endPoints)):
            r = ratios[endPoints[bagNum - 1]:endPoints[bagNum]]
            bagRatios.append(r)
        return bagRatios

    def formatComponentInfo(self,componentInfo):
        """
        The components found by kmeans likely don't match the true order of the components,
        find the mapping and create EasyDicts for each comp

        Arguments:
        - componentInfo EasyDict with fields:
            - posMeans : length <numComps> list of (<dim>) ndarrays
            - negMeans : length <numComps> list of (<dim>) ndarrays
            - posCovs  : length <numComps> list of (<dim>,<dim>) ndarrays
            - negCovs  : length <numComps> list of (<dim>,<dim>) ndarrays
            - dgs      : list of GaussianMixtureDataGenerator objects (see multiinstance.data.gaussian_dg)
        """
        if componentInfo is None:
            self.components = None
            return
        # maps kmeans cluster to true component index
        clusterMap = cdist(self.kmeans.cluster_centers_, componentInfo.posMeans).argmin(1)
        self.components = []
        for comp in clusterMap:
            compInfo = EasyDict()
            compInfo.posMean = componentInfo.posMeans[comp]
            compInfo.negMean = componentInfo.negMeans[comp]
            compInfo.posCov = componentInfo.posCovs[comp]
            compInfo.negCov = componentInfo.negCovs[comp]
            compInfo.dg = componentInfo.dgs[comp]
            compInfo.r = componentInfo.rs[comp]
            self.components.append(compInfo)

    def getBagRatios(self,inputType,componentInfo=None):
        """
        Arguments:
        - inputType : {true posterior,
                       estimated posterior,
                       nnpu raw,
                       nnpu transform,
                       nnpu estimated rank,
                       nnpu true rank}
        - componentInfo : Required if inputType in {"true posterior","nnpu true rank"}
            - See self.formatComponentInfo for details

        """
        # NClusters x NBags size list containing the density ratio for the unlabeled points
        # from the specified bag in the specified cluster
        self.bagRatios = []
        self.debugLabels= []
        self.debugPosteriors = []
        self.formatComponentInfo(componentInfo)
        for cnum in trange(self.n_clusters):
            if inputType == "true posterior":
                ratios = self.trueDensityRatio(cnum)
            elif inputType == "estimated posterior":
                ratios = self.densityRatioFromEstimatedPNPosterior(cnum)
            elif inputType == "ratio estimation":
                ratios = self.ratioEstimation(cnum)
            elif "nnpu" in inputType:
                ratios = self.estimateClusterDensityRatio(cnum,inputType.replace("nnpu ",""))
            else:
                raise ValueError("Invalid inputType specified: {}".format(inputType))
            self.bagRatios.append(self.splitRatiosIntoBags(ratios,cnum))
#         print(roc_auc_score(np.concatenate(self.debugLabels),
#                             np.concatenate(self.debugPosteriors)))
    def EM(self,NIters=500):
        self.eta = np.ones((len(self.bags), self.n_clusters)) * self.clusterAlphaHats
#         self.eta = np.copy(self.trueEta)
        plt.scatter(self.eta.ravel(), self.trueEta.ravel())
        plt.plot([0,1],[0,1])
        plt.title(np.mean(np.abs(self.eta - self.trueEta)))
        plt.show()
        for em_iter in range(NIters):
            for cnum in range(self.n_clusters):
                for bagNum,b in enumerate(self.bags):
                    ratios = self.bagRatios[cnum][bagNum]
                    comp = self.components[cnum]
                    unlabeled = b.x_unlabeled[b.unlabeled_cluster_assignment == cnum]
                    positive = b.X_pos[b.positive_cluster_assignment == cnum]
                    f1 = ss.multivariate_normal.pdf(unlabeled,
                                                    mean=comp.posMean,
                                                    cov=comp.posCov)
                    # Negative density
                    f0 = ss.multivariate_normal.pdf(unlabeled,
                                                    mean=comp.negMean,
                                                    cov=comp.negCov)
                    eij = self.eta[bagNum,cnum]
                    densities = eij * f1 + (1-eij) * f0
                    densities = densities / densities.sum()
                    posts = eij * f1 / (eij * f1 + (1 - eij) * f0)
                    plt.hist(posts,density=True)
                    plt.vlines(np.mean(posts),0,10,color="red")
                    plt.vlines(self.trueEta[bagNum,cnum],0,10,color="black")
                    plt.xlim(0,1)
                    plt.show()
                    self.eta[bagNum,cnum] = np.mean(posts)
            plt.scatter(self.eta.ravel(), self.trueEta.ravel())
            plt.plot([0,1],[0,1])
            plt.title(np.mean(np.abs(self.eta - self.trueEta)))
            plt.show()

    def run(self,densityRatioInputType,componentInfo=None):
        self.getBagRatios(densityRatioInputType, componentInfo=componentInfo)
        self.EM()
        self.estimateBagParameters()


    def posterior(self, bagNum, clusterNum):
        eta_i_j = self.eta[bagNum, clusterNum]
        densityRatios = self.bagRatios[clusterNum][bagNum]
        return eta_i_j / (eta_i_j + (1 - eta_i_j)*densityRatios)

    def getAUC(self):
        labels = []
        posts = []
        for bagNum in range(len(self.bags)):
            for cnum in range(self.n_clusters):
                posts.append(self.posterior(bagNum,cnum))
                labels.append(self.bags[bagNum].hiddenLabels[self.bags[bagNum].unlabeled_cluster_assignment == cnum])
        labels = np.concatenate(labels)
        posts = np.concatenate(posts)
        return roc_auc_score(labels, posts)

    def estimateBagParameters(self):
        N = len(self.bags)
        self.alphaHats = np.zeros(N)
        self.pi = np.zeros((N,self.n_clusters))
        self.rho = np.zeros((N,self.n_clusters))
        for bagNum, b in enumerate(self.bags):
            eta_j = self.eta[bagNum]
            gamma_j = np.unique(b.unlabeled_cluster_assignment,
                                return_counts=True)[1] / b.unlabeled_cluster_assignment.shape[0]
            alpha_j = eta_j.dot(gamma_j)
            pi_j = np.multiply(eta_j, gamma_j) / alpha_j
            rho_j = np.multiply(1 - eta_j, gamma_j) / (1 - alpha_j)
            self.alphaHats[bagNum] = alpha_j
            self.pi[bagNum] = pi_j
            self.rho[bagNum] = rho_j

# Cell
def generateParams(nClusters, nComps, dim,aucpn_range=[0.8,0.85]):
    posMeans,posCovs,negMeans,negCovs,dgs,rs =[], [],[],[],[],[]
    for comp in range(nClusters):
        dg = GaussianMixtureDataGenerator(dim,nComps,aucpn_range,100,1000)
        pos,neg = dg.components_pos[0], dg.components_neg[0]
        r = np.zeros(dim)
        for _ in range(1):
            r += np.random.normal(loc=0,scale=10,size=dim)
        posMeans.append(pos.mean+r)
        posCovs.append(pos.cov)
        negMeans.append(neg.mean+r)
        negCovs.append(neg.cov)
        dgs.append(dg)
        rs.append(r)
    return EasyDict({"posMeans":posMeans,
                     "posCovs": posCovs,
                     "negMeans": negMeans,
                     "negCovs": negCovs,
                     "dgs":dgs,
                     "rs": rs})